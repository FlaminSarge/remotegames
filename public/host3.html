<html>

<head>
	<title>Lagless 4 video host</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.0/socket.io.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.3.0/simplepeer.min.js"></script>
	<script src="https://webrtcexperiment-webrtc.netdna-ssl.com/BandwidthHandler.js"></script>

	<script src="https://cdn.WebRTC-Experiment.com/getScreenId.js"></script>
	<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
</head>

<body>
	<video id="localVideo"></video>
	<canvas id="localCanvas" width="1280" height="720"></canvas>
	<script>
		// https://stackoverflow.com/questions/16712224/how-to-control-bandwidth-in-webrtc-video-call

		// example:
		// 		var bandwidth = {
		// 			screen: 300, // 300kbits minimum
		// 			audio: 50,   // 50kbits  minimum
		// 			video: 256   // 256kbits (both min-max)
		// 		};
		// 		var isScreenSharing = false;

		// 		sdp = BandwidthHandler.setApplicationSpecificBandwidth(sdp, bandwidth, isScreenSharing);
		// 		sdp = BandwidthHandler.setVideoBitrates(sdp, {
		// 			min: bandwidth.video,
		// 			max: bandwidth.video
		// 		});
		// 		sdp = BandwidthHandler.setOpusAttributes(sdp);
		// 		sdp = BandwidthHandler.setOpusAttributes(sdp, {
		// 			'stereo': 0, // to disable stereo (to force mono audio)
		// 			'sprop-stereo': 1,
		// 			'maxaveragebitrate': 500 * 1024 * 8, // 500 kbits
		// 			'maxplaybackrate': 500 * 1024 * 8, // 500 kbits
		// 			'cbr': 0, // disable cbr
		// 			'useinbandfec': 1, // use inband fec
		// 			'usedtx': 1, // use dtx
		// 			'maxptime': 3
		// 		});

		function mySDPTransform(sdp) {
			// 			sdp = BandwidthHandler.setOpusAttributes(sdp, {
			// 				'stereo': 0, // to disable stereo (to force mono audio)
			// 				'sprop-stereo': 1,
			// 				'maxaveragebitrate': 500 * 1024 * 8, // 500 kbits
			// 				'maxplaybackrate': 500 * 1024 * 8, // 500 kbits
			// 				'cbr': 0, // disable cbr
			// 				'useinbandfec': 1, // use inband fec
			// 				'usedtx': 1, // use dtx
			// 				'maxptime': 3
			// 			});

			var bandwidth = {
				screen: 2048, // 300kbits minimum
				audio: 200, // 500kbits  minimum
				video: 2048, // 256kbits (both min-max)
			};
			var isScreenSharing = true;

			sdp = BandwidthHandler.setApplicationSpecificBandwidth(sdp, bandwidth, isScreenSharing);
			sdp = BandwidthHandler.setVideoBitrates(sdp, {
				min: bandwidth.video,
				max: bandwidth.video,
			});
			sdp = BandwidthHandler.setOpusAttributes(sdp);

			return sdp;
		}



		// 		navigator.mediaDevices.getUserMedia({video: {mediaSource: "screen"}}).then(stream => {
		// 			// we have a stream, attach it to a feedback video element
		// 			videoElement.srcObject = stream;
		// 		}, error => {
		// 			console.log("Unable to acquire screen capture", error);
		// 		});


		let socket = io("https://remotegames.io", {
			path: "/8100/socket.io/",
		});

		socket.emit("join", "videoHost");
		setInterval(() => {
			socket.emit("join", "videoHost");
		}, 5000);

		let clients = [];
		let localStream;

		function Client(id, peer) {
			this.id = id;
			this.peer = peer;
			return this;
		}

		function findClientByID(id) {
			let index = -1;
			for (let i = 0; i < clients.length; i++) {
				if (clients[i].id == id) {
					index = i;
					return index;
				}
			}
			return index;
		}


		// get video/voice stream

		let scale = 50;
		let fps = 60;
		let sw = 1920;
		let sh = 1080;

// 		let canvas = document.querySelector("canvas");
// 		let localVideo = document.querySelector("video");
		let localVideo = document.createElement("video");
		let canvas = document.createElement("canvas");
		canvas.width = sw * (scale / 100);
		canvas.height = sh * (scale / 100);
		let ctx = canvas.getContext("2d");

		function drawToCanvas() {
			// draw the current frame of localVideo onto the canvas,
			// starting at 0, 0 (top-left corner)
			let sx = 0;
			let sy = 0;
			let swidth = sw;
			let sheight = sh;
			let dx = 0;
			let dy = 0;
			let dw = sw * (scale / 100);
			let dh = sh * (scale / 100);
			ctx.drawImage(localVideo, sx, sy, swidth, sheight, dx, dy, dw, dh);

			//repeat this every time a new frame becomes available using
			//the browser's built-in requestAnimationFrame method
			requestAnimationFrame(drawToCanvas);
		}

		getScreenId((error, sourceId, screen_constraints) => {
			// error    == null || 'permission-denied' || 'not-installed' || 'installed-disabled' || 'not-chrome'
			// sourceId == null || 'string' || 'firefox'

			if (navigator.userAgent.indexOf("Edge") !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob)) {
				navigator.getDisplayMedia(screen_constraints).then(stream => {
					localVideo.srcObject = stream;
				}, error => {
					alert("Please make sure to use Edge 17 or higher.");
				});
				return;
			}

			if (error == "not-installed") {
				alert("Please install the Chrome extension.");
				return;
			}

			navigator.mediaDevices.getUserMedia(screen_constraints).then((stream) => {
				try {
					localVideo.src = window.URL.createObjectURL(stream);
				} catch(error) {
					localVideo.srcObject = stream;
				}
				localVideo.play();
// 				localStream = stream;
				drawToCanvas();
				localStream = canvas.captureStream(fps);
				// share this "MediaStream" object using RTCPeerConnection API
			}).catch((error) => {
				console.error("getScreenId error", error);
				alert("Failed to capture your screen. Please check Chrome console logs for further information.");
			});
		});





		socket.on("createNewPeerV", function(data) {

			let id = data.id;

			let peer = new SimplePeer({
				initiator: true,
				trickle: true,
				stream: localStream,
				sdpTransform: mySDPTransform,
			});

			peer.on("error", (error) => {
				console.log("error", error)
			});

			peer.on("signal", (data) => {
				console.log("SIGNAL", JSON.stringify(data));
				console.log(id);
				let obj = {
					id: id,
					data: JSON.stringify(data)
				};
				socket.emit("hostPeerSignalReplyV", obj);
			});

			peer.on("connect", () => {
				console.log("CONNECT");
				peer.send(Math.random());
			});

			peer.on("data", (data) => {
				console.log("data: " + data)
			});

			let client = Client(id, peer);
			clients.push(client);
		});

		socket.on("clientPeerSignalV", (data) => {
			let index = findClientByID(data.id);
			if (index == -1) {
				return;
			}
			clients[index].peer.signal(JSON.parse(data.data));
		});

		// todo: remove disconnected peers somehow
		// 		setTimeout(function() {

		// 		});
	</script>
</body>

</html>
