<html>

<head>
	<title>Lagless 1 video host</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.0/socket.io.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.3.0/simplepeer.min.js"></script>

	<script src="https://cdn.WebRTC-Experiment.com/getScreenId.js"></script>
	<!-- <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script> -->
</head>

<body>
	<video id="localVideo"></video>
	<canvas id="localCanvas" width="1920" height="1080"></canvas>
	<script>



		// 		navigator.mediaDevices.getUserMedia({video: {mediaSource: "screen"}}).then(stream => {
		// 			// we have a stream, attach it to a feedback video element
		// 			videoElement.srcObject = stream;
		// 		}, error => {
		// 			console.log("Unable to acquire screen capture", error);
		// 		});


		let socket = io("https://remotegames.io", {
			path: "/8100/socket.io/",
		});

		// socket.emit("join", "videoHost");
		// setInterval(function() {
		// 	socket.emit("join", "videoHost");
		// }, 5000);

		let clients = [];
		let localStream;

		// get video/voice stream

		let scale = 30;
		let fps = 30;
		let sw = 1920;
		let sh = 1080;

// 		let canvas = document.querySelector("canvas");
// 		let localVideo = document.querySelector("video");
		let localVideo = document.createElement("video");
		let canvas = document.createElement("canvas");
		canvas.width = sw * (scale / 100);
		canvas.height = sh * (scale / 100);
		let ctx = canvas.getContext("2d");

		let sync = false;

		function drawToCanvas() {
			// draw the current frame of localVideo onto the canvas,
			// starting at 0, 0 (top-left corner)
			let sx = 0;
			let sy = 0;
			let swidth = sw;
			let sheight = sh;
			let dx = 0;
			let dy = 0;
			let dw = dw * (scale / 100);
			let dh = dh * (scale / 100);
			ctx.drawImage(localVideo, sx, sy, swidth, sheight, dx, dy, dw, dh);

			if (sync) {
				socket.emit("video", canvas.toDataURL("image/webp"));
			}

			//repeat this every time a new frame becomes available using
			//the browser's built-in requestAnimationFrame method
			requestAnimationFrame(drawToCanvas);
		}

		getScreenId(function(error, sourceId, screen_constraints) {
			// error    == null || 'permission-denied' || 'not-installed' || 'installed-disabled' || 'not-chrome'
			// sourceId == null || 'string' || 'firefox'

			if (navigator.userAgent.indexOf("Edge") !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob)) {
				navigator.getDisplayMedia(screen_constraints).then(stream => {
					localVideo.srcObject = stream;
				}, error => {
					alert("Please make sure to use Edge 17 or higher.");
				});
				return;
			}

			if (error == "not-installed") {
				alert("Please install the Chrome extension.");
				return;
			}

			navigator.mediaDevices.getUserMedia(screen_constraints).then(function(stream) {
				localVideo.srcObject = stream;
				localVideo.play();
// 				localStream = stream;
				drawToCanvas();
				// localStream = canvas.captureStream(fps);
				// share this "MediaStream" object using RTCPeerConnection API
			}).catch(function(error) {
				console.error("getScreenId error", error);
				alert("Failed to capture your screen. Please check Chrome console logs for further information.");
			});
		});

		if (!sync) {
			setInterval(() => {
				socket.emit("video", canvas.toDataURL("image/webp"));
			}, 1000 / fps);
		}



	</script>
</body>

</html>
